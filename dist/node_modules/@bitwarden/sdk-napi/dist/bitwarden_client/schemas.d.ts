/**
 * Basic client behavior settings. These settings specify the various targets and behavior
 * of the Bitwarden Client. They are optional and uneditable once the client is
 * initialized.
 *
 * Defaults to
 *
 * ``` # use bitwarden::client::client_settings::{ClientSettings, DeviceType}; # use
 * assert_matches::assert_matches; let settings = ClientSettings { identity_url:
 * "https://identity.bitwarden.com".to_string(), api_url:
 * "https://api.bitwarden.com".to_string(), user_agent: "Bitwarden Rust-SDK".to_string(),
 * device_type: DeviceType::SDK, }; let default = ClientSettings::default();
 * assert_matches!(settings, default); ```
 *
 * Targets `localhost:8080` for debug builds.
 */
export interface ClientSettings {
    /**
     * The api url of the targeted Bitwarden instance. Defaults to `https://api.bitwarden.com`
     */
    apiUrl?: string;
    /**
     * Device type to send to Bitwarden. Defaults to SDK
     */
    deviceType?: DeviceType;
    /**
     * The identity url of the targeted Bitwarden instance. Defaults to
     * `https://identity.bitwarden.com`
     */
    identityUrl?: string;
    /**
     * The user_agent to sent to Bitwarden. Defaults to `Bitwarden Rust-SDK`
     */
    userAgent?: string;
}
/**
 * Device type to send to Bitwarden. Defaults to SDK
 */
export declare enum DeviceType {
    Android = "Android",
    AndroidAmazon = "AndroidAmazon",
    ChromeBrowser = "ChromeBrowser",
    ChromeExtension = "ChromeExtension",
    EdgeBrowser = "EdgeBrowser",
    EdgeExtension = "EdgeExtension",
    FirefoxBrowser = "FirefoxBrowser",
    FirefoxExtension = "FirefoxExtension",
    IEBrowser = "IEBrowser",
    IOS = "iOS",
    LinuxDesktop = "LinuxDesktop",
    MACOSDesktop = "MacOsDesktop",
    OperaBrowser = "OperaBrowser",
    OperaExtension = "OperaExtension",
    SDK = "SDK",
    SafariBrowser = "SafariBrowser",
    SafariExtension = "SafariExtension",
    UWP = "UWP",
    UnknownBrowser = "UnknownBrowser",
    VivaldiBrowser = "VivaldiBrowser",
    VivaldiExtension = "VivaldiExtension",
    WindowsDesktop = "WindowsDesktop"
}
/**
 * Login with username and password
 *
 * This command is for initiating an authentication handshake with Bitwarden. Authorization
 * may fail due to requiring 2fa or captcha challenge completion despite accurate
 * credentials.
 *
 * This command is not capable of handling authentication requiring 2fa or captcha.
 *
 * Returns: [PasswordLoginResponse](bitwarden::auth::login::PasswordLoginResponse)
 *
 * Login with API Key
 *
 * This command is for initiating an authentication handshake with Bitwarden.
 *
 * Returns: [ApiKeyLoginResponse](bitwarden::auth::login::ApiKeyLoginResponse)
 *
 * Login with Secrets Manager Access Token
 *
 * This command is for initiating an authentication handshake with Bitwarden.
 *
 * Returns: [ApiKeyLoginResponse](bitwarden::auth::login::ApiKeyLoginResponse)
 *
 * > Requires Authentication Get the API key of the currently authenticated user
 *
 * Returns: [UserApiKeyResponse](bitwarden::platform::UserApiKeyResponse)
 *
 * Get the user's passphrase
 *
 * Returns: String
 *
 * > Requires Authentication Retrieve all user data, ciphers and organizations the user is a
 * part of
 *
 * Returns: [SyncResponse](bitwarden::platform::SyncResponse)
 */
export interface Command {
    passwordLogin?: PasswordLoginRequest;
    apiKeyLogin?: APIKeyLoginRequest;
    accessTokenLogin?: AccessTokenLoginRequest;
    getUserApiKey?: SecretVerificationRequest;
    fingerprint?: FingerprintRequest;
    sync?: SyncRequest;
    secrets?: SecretsCommand;
    projects?: ProjectsCommand;
}
/**
 * Login to Bitwarden with access token
 */
export interface AccessTokenLoginRequest {
    /**
     * Bitwarden service API access token
     */
    accessToken: string;
}
/**
 * Login to Bitwarden with Api Key
 */
export interface APIKeyLoginRequest {
    /**
     * Bitwarden account client_id
     */
    clientId: string;
    /**
     * Bitwarden account client_secret
     */
    clientSecret: string;
    /**
     * Bitwarden account master password
     */
    password: string;
}
export interface FingerprintRequest {
    /**
     * The input material, used in the fingerprint generation process.
     */
    fingerprintMaterial: string;
    /**
     * The user's public key encoded with base64.
     */
    publicKey: string;
}
export interface SecretVerificationRequest {
    /**
     * The user's master password to use for user verification. If supplied, this will be used
     * for verification purposes.
     */
    masterPassword?: null | string;
    /**
     * Alternate user verification method through OTP. This is provided for users who have no
     * master password due to use of Customer Managed Encryption. Must be present and valid if
     * master_password is absent.
     */
    otp?: null | string;
}
/**
 * Login to Bitwarden with Username and Password
 */
export interface PasswordLoginRequest {
    /**
     * Bitwarden account email address
     */
    email: string;
    /**
     * Kdf from prelogin
     */
    kdf: PasswordLoginKdf;
    /**
     * Bitwarden account master password
     */
    password: string;
    twoFactor?: TwoFactorRequest | null;
}
/**
 * Kdf from prelogin
 */
export interface PasswordLoginKdf {
    pBKDF2?: PurplePBKDF2;
    argon2id?: PurpleArgon2ID;
}
export interface PurpleArgon2ID {
    iterations: number;
    memory: number;
    parallelism: number;
}
export interface PurplePBKDF2 {
    iterations: number;
}
export interface TwoFactorRequest {
    /**
     * Two-factor provider
     */
    provider: TwoFactorProvider;
    /**
     * Two-factor remember
     */
    remember: boolean;
    /**
     * Two-factor Token
     */
    token: string;
}
/**
 * Two-factor provider
 */
export declare enum TwoFactorProvider {
    Authenticator = "Authenticator",
    Duo = "Duo",
    Email = "Email",
    OrganizationDuo = "OrganizationDuo",
    Remember = "Remember",
    U2F = "U2f",
    WebAuthn = "WebAuthn",
    Yubikey = "Yubikey"
}
/**
 * > Requires Authentication > Requires using an Access Token for login or calling Sync at
 * least once Retrieve a project by the provided identifier
 *
 * Returns: [ProjectResponse](bitwarden::secrets_manager::projects::ProjectResponse)
 *
 * > Requires Authentication > Requires using an Access Token for login or calling Sync at
 * least once Creates a new project in the provided organization using the given data
 *
 * Returns: [ProjectResponse](bitwarden::secrets_manager::projects::ProjectResponse)
 *
 * > Requires Authentication > Requires using an Access Token for login or calling Sync at
 * least once Lists all projects of the given organization
 *
 * Returns: [ProjectsResponse](bitwarden::secrets_manager::projects::ProjectsResponse)
 *
 * > Requires Authentication > Requires using an Access Token for login or calling Sync at
 * least once Updates an existing project with the provided ID using the given data
 *
 * Returns: [ProjectResponse](bitwarden::secrets_manager::projects::ProjectResponse)
 *
 * > Requires Authentication > Requires using an Access Token for login or calling Sync at
 * least once Deletes all the projects whose IDs match the provided ones
 *
 * Returns:
 * [ProjectsDeleteResponse](bitwarden::secrets_manager::projects::ProjectsDeleteResponse)
 */
export interface ProjectsCommand {
    get?: ProjectGetRequest;
    create?: ProjectCreateRequest;
    list?: ProjectsListRequest;
    update?: ProjectPutRequest;
    delete?: ProjectsDeleteRequest;
}
export interface ProjectCreateRequest {
    name: string;
    /**
     * Organization where the project will be created
     */
    organizationId: string;
}
export interface ProjectsDeleteRequest {
    /**
     * IDs of the projects to delete
     */
    ids: string[];
}
export interface ProjectGetRequest {
    /**
     * ID of the project to retrieve
     */
    id: string;
}
export interface ProjectsListRequest {
    /**
     * Organization to retrieve all the projects from
     */
    organizationId: string;
}
export interface ProjectPutRequest {
    /**
     * ID of the project to modify
     */
    id: string;
    name: string;
    /**
     * Organization ID of the project to modify
     */
    organizationId: string;
}
/**
 * > Requires Authentication > Requires using an Access Token for login or calling Sync at
 * least once Retrieve a secret by the provided identifier
 *
 * Returns: [SecretResponse](bitwarden::secrets_manager::secrets::SecretResponse)
 *
 * > Requires Authentication > Requires using an Access Token for login or calling Sync at
 * least once Retrieve secrets by the provided identifiers
 *
 * Returns: [SecretsResponse](bitwarden::secrets_manager::secrets::SecretsResponse)
 *
 * > Requires Authentication > Requires using an Access Token for login or calling Sync at
 * least once Creates a new secret in the provided organization using the given data
 *
 * Returns: [SecretResponse](bitwarden::secrets_manager::secrets::SecretResponse)
 *
 * > Requires Authentication > Requires using an Access Token for login or calling Sync at
 * least once Lists all secret identifiers of the given organization, to then retrieve each
 * secret, use `CreateSecret`
 *
 * Returns:
 * [SecretIdentifiersResponse](bitwarden::secrets_manager::secrets::SecretIdentifiersResponse)
 *
 * > Requires Authentication > Requires using an Access Token for login or calling Sync at
 * least once Updates an existing secret with the provided ID using the given data
 *
 * Returns: [SecretResponse](bitwarden::secrets_manager::secrets::SecretResponse)
 *
 * > Requires Authentication > Requires using an Access Token for login or calling Sync at
 * least once Deletes all the secrets whose IDs match the provided ones
 *
 * Returns:
 * [SecretsDeleteResponse](bitwarden::secrets_manager::secrets::SecretsDeleteResponse)
 */
export interface SecretsCommand {
    get?: SecretGetRequest;
    getByIds?: SecretsGetRequest;
    create?: SecretCreateRequest;
    list?: SecretIdentifiersRequest;
    update?: SecretPutRequest;
    delete?: SecretsDeleteRequest;
}
export interface SecretCreateRequest {
    key: string;
    note: string;
    /**
     * Organization where the secret will be created
     */
    organizationId: string;
    /**
     * IDs of the projects that this secret will belong to
     */
    projectIds?: string[] | null;
    value: string;
}
export interface SecretsDeleteRequest {
    /**
     * IDs of the secrets to delete
     */
    ids: string[];
}
export interface SecretGetRequest {
    /**
     * ID of the secret to retrieve
     */
    id: string;
}
export interface SecretsGetRequest {
    /**
     * IDs of the secrets to retrieve
     */
    ids: string[];
}
export interface SecretIdentifiersRequest {
    /**
     * Organization to retrieve all the secrets from
     */
    organizationId: string;
}
export interface SecretPutRequest {
    /**
     * ID of the secret to modify
     */
    id: string;
    key: string;
    note: string;
    /**
     * Organization ID of the secret to modify
     */
    organizationId: string;
    projectIds?: string[] | null;
    value: string;
}
export interface SyncRequest {
    /**
     * Exclude the subdomains from the response, defaults to false
     */
    excludeSubdomains?: boolean | null;
}
export interface DocRef {
    Cipher?: Cipher;
    CipherView?: CipherView;
    Collection?: Collection;
    Folder?: Folder;
    FolderView?: FolderView;
    Send?: Send;
    SendView?: SendView;
    SendListView?: SendListView;
    InitCryptoRequest?: InitCryptoRequest;
    PasswordGeneratorRequest?: PasswordGeneratorRequest;
    PassphraseGeneratorRequest?: PassphraseGeneratorRequest;
    ExportFormat?: ExportFormatClass | ExportFormatEnum;
    MasterPasswordPolicyOptions?: MasterPasswordPolicyOptions;
    Kdf?: InitCryptoRequestKdf;
}
export interface Cipher {
    attachments?: Attachment[] | null;
    card?: Card | null;
    collectionIds: string[];
    creationDate: Date;
    deletedDate?: Date | null;
    edit: boolean;
    favorite: boolean;
    fields?: Field[] | null;
    folderId?: null | string;
    id?: null | string;
    identity?: Identity | null;
    localData?: LocalData | null;
    login?: Login | null;
    name: string;
    notes?: null | string;
    organizationId?: null | string;
    organizationUseTotp: boolean;
    passwordHistory?: PasswordHistory[] | null;
    reprompt: CipherRepromptType;
    revisionDate: Date;
    secureNote?: SecureNote | null;
    type: CipherType;
    viewPassword: boolean;
}
export interface Attachment {
    fileName?: null | string;
    id?: null | string;
    key?: null | string;
    size?: null | string;
    /**
     * Readable size, ex: "4.2 KB" or "1.43 GB"
     */
    sizeName?: null | string;
    url?: null | string;
}
export interface Card {
    brand?: null | string;
    cardholderName?: null | string;
    code?: null | string;
    expMonth?: null | string;
    expYear?: null | string;
    number?: null | string;
}
export interface Field {
    linkedId?: LinkedIDType | null;
    name?: null | string;
    type: FieldType;
    value?: null | string;
}
export declare enum LinkedIDType {
    Address1 = "Address1",
    Address2 = "Address2",
    Address3 = "Address3",
    Brand = "Brand",
    CardholderName = "CardholderName",
    City = "City",
    Code = "Code",
    Company = "Company",
    Country = "Country",
    Email = "Email",
    ExpMonth = "ExpMonth",
    ExpYear = "ExpYear",
    FirstName = "FirstName",
    FullName = "FullName",
    LastName = "LastName",
    LicenseNumber = "LicenseNumber",
    MiddleName = "MiddleName",
    Number = "Number",
    PassportNumber = "PassportNumber",
    Password = "Password",
    Phone = "Phone",
    PostalCode = "PostalCode",
    Ssn = "Ssn",
    State = "State",
    Title = "Title",
    Username = "Username"
}
export declare enum FieldType {
    Boolean = "Boolean",
    Hidden = "Hidden",
    Linked = "Linked",
    Text = "Text"
}
export interface Identity {
    address1?: null | string;
    address2?: null | string;
    address3?: null | string;
    city?: null | string;
    company?: null | string;
    country?: null | string;
    email?: null | string;
    firstName?: null | string;
    lastName?: null | string;
    licenseNumber?: null | string;
    middleName?: null | string;
    passportNumber?: null | string;
    phone?: null | string;
    postalCode?: null | string;
    ssn?: null | string;
    state?: null | string;
    title?: null | string;
    username?: null | string;
}
export interface LocalData {
    lastLaunched?: number | null;
    lastUsedDate?: number | null;
}
export interface Login {
    autofillOnPageLoad?: boolean | null;
    password?: null | string;
    passwordRevisionDate?: Date | null;
    totp?: null | string;
    uris?: LoginURI[] | null;
    username?: null | string;
}
export interface LoginURI {
    match?: URIMatchType | null;
    uri?: null | string;
}
export declare enum URIMatchType {
    Domain = "domain",
    Exact = "exact",
    Host = "host",
    Never = "never",
    RegularExpression = "regularExpression",
    StartsWith = "startsWith"
}
export interface PasswordHistory {
    lastUsedDate: Date;
    password: string;
}
export declare enum CipherRepromptType {
    None = "None",
    Password = "Password"
}
export interface SecureNote {
    type: SecureNoteType;
}
export declare enum SecureNoteType {
    Generic = "Generic"
}
export declare enum CipherType {
    Card = "Card",
    Identity = "Identity",
    Login = "Login",
    SecureNote = "SecureNote"
}
export interface CipherView {
    attachments?: AttachmentView[] | null;
    card?: CardView | null;
    collectionIds: string[];
    creationDate: Date;
    deletedDate?: Date | null;
    edit: boolean;
    favorite: boolean;
    fields?: FieldView[] | null;
    folderId?: null | string;
    id?: null | string;
    identity?: IdentityView | null;
    localData?: LocalDataView | null;
    login?: LoginView | null;
    name: string;
    notes?: null | string;
    organizationId?: null | string;
    organizationUseTotp: boolean;
    passwordHistory?: PasswordHistoryView[] | null;
    reprompt: CipherRepromptType;
    revisionDate: Date;
    secureNote?: SecureNoteView | null;
    type: CipherType;
    viewPassword: boolean;
}
export interface AttachmentView {
    fileName?: null | string;
    id?: null | string;
    key?: null | string;
    size?: null | string;
    sizeName?: null | string;
    url?: null | string;
}
export interface CardView {
    brand?: null | string;
    cardholderName?: null | string;
    code?: null | string;
    expMonth?: null | string;
    expYear?: null | string;
    number?: null | string;
}
export interface FieldView {
    linkedId?: LinkedIDType | null;
    name?: null | string;
    type: FieldType;
    value?: null | string;
}
export interface IdentityView {
    address1?: null | string;
    address2?: null | string;
    address3?: null | string;
    city?: null | string;
    company?: null | string;
    country?: null | string;
    email?: null | string;
    firstName?: null | string;
    lastName?: null | string;
    licenseNumber?: null | string;
    middleName?: null | string;
    passportNumber?: null | string;
    phone?: null | string;
    postalCode?: null | string;
    ssn?: null | string;
    state?: null | string;
    title?: null | string;
    username?: null | string;
}
export interface LocalDataView {
    lastLaunched?: number | null;
    lastUsedDate?: number | null;
}
export interface LoginView {
    autofillOnPageLoad?: boolean | null;
    password?: null | string;
    passwordRevisionDate?: Date | null;
    totp?: null | string;
    uris?: LoginURIView[] | null;
    username?: null | string;
}
export interface LoginURIView {
    match?: URIMatchType | null;
    uri?: null | string;
}
export interface PasswordHistoryView {
    lastUsedDate: Date;
    password: string;
}
export interface SecureNoteView {
    type: SecureNoteType;
}
export interface Collection {
    externalId?: null | string;
    hidePasswords: boolean;
    id: string;
    name: string;
    organizationId: string;
    readOnly: boolean;
}
export interface ExportFormatClass {
    EncryptedJson: EncryptedJSON;
}
export interface EncryptedJSON {
    password: string;
    [property: string]: any;
}
export declare enum ExportFormatEnum {
    AccountEncryptedJSON = "AccountEncryptedJson",
    CSV = "Csv",
    JSON = "Json"
}
export interface Folder {
    id: string;
    name: string;
    revisionDate: Date;
    [property: string]: any;
}
export interface FolderView {
    id: string;
    name: string;
    revisionDate: Date;
    [property: string]: any;
}
export interface InitCryptoRequest {
    /**
     * The user's email address
     */
    email: string;
    /**
     * The user's KDF parameters, as received from the prelogin request
     */
    kdfParams: InitCryptoRequestKdf;
    /**
     * The encryption keys for all the organizations the user is a part of
     */
    organizationKeys: {
        [key: string]: string;
    };
    /**
     * The user's master password
     */
    password: string;
    /**
     * The user's encryptred private key
     */
    privateKey: string;
    /**
     * The user's encrypted symmetric crypto key
     */
    userKey: string;
}
/**
 * The user's KDF parameters, as received from the prelogin request
 */
export interface InitCryptoRequestKdf {
    pBKDF2?: FluffyPBKDF2;
    argon2id?: FluffyArgon2ID;
}
export interface FluffyArgon2ID {
    iterations: number;
    memory: number;
    parallelism: number;
}
export interface FluffyPBKDF2 {
    iterations: number;
}
export interface MasterPasswordPolicyOptions {
    /**
     * Flag to indicate if the policy should be enforced on login. If true, and the user's
     * password does not meet the policy requirements, the user will be forced to update their
     * password.
     */
    enforce_on_login: boolean;
    min_complexity: number;
    min_length: number;
    require_lower: boolean;
    require_numbers: boolean;
    require_special: boolean;
    require_upper: boolean;
    [property: string]: any;
}
/**
 * Passphrase generator request.
 *
 * The default separator is `-` and default number of words is 3.
 */
export interface PassphraseGeneratorRequest {
    capitalize?: boolean | null;
    includeNumber?: boolean | null;
    numWords?: number | null;
    wordSeparator?: null | string;
}
/**
 * Password generator request. If all options are false, the default is to generate a
 * password with: - lowercase - uppercase - numbers
 *
 * The default length is 16.
 */
export interface PasswordGeneratorRequest {
    avoidAmbiguous?: boolean | null;
    length?: number | null;
    lowercase: boolean;
    minLowercase?: boolean | null;
    minNumber?: boolean | null;
    minSpecial?: boolean | null;
    minUppercase?: boolean | null;
    numbers: boolean;
    special: boolean;
    uppercase: boolean;
}
export interface Send {
    accessCount: number;
    accessId: string;
    deletionDate: Date;
    disabled: boolean;
    expirationDate?: Date | null;
    file?: SendFile | null;
    hideEmail: boolean;
    id: string;
    key: string;
    maxAccessCount?: number | null;
    name: string;
    notes?: null | string;
    password?: null | string;
    revisionDate: Date;
    text?: SendText | null;
    type: SendType;
}
export interface SendFile {
    fileName: string;
    id: string;
    size: string;
    /**
     * Readable size, ex: "4.2 KB" or "1.43 GB"
     */
    sizeName: string;
}
export interface SendText {
    hidden: boolean;
    text?: null | string;
}
export declare enum SendType {
    File = "File",
    Text = "Text"
}
export interface SendListView {
    accessId: string;
    deletionDate: Date;
    disabled: boolean;
    expirationDate?: Date | null;
    id: string;
    name: string;
    revisionDate: Date;
    type: SendType;
}
export interface SendView {
    accessCount: number;
    accessId: string;
    deletionDate: Date;
    disabled: boolean;
    expirationDate?: Date | null;
    file?: SendFileView | null;
    hideEmail: boolean;
    id: string;
    key: string;
    maxAccessCount?: number | null;
    name: string;
    notes?: null | string;
    password?: null | string;
    revisionDate: Date;
    text?: SendTextView | null;
    type: SendType;
}
export interface SendFileView {
    fileName: string;
    id: string;
    size: string;
    /**
     * Readable size, ex: "4.2 KB" or "1.43 GB"
     */
    sizeName: string;
}
export interface SendTextView {
    hidden: boolean;
    text?: null | string;
}
export interface ResponseForAPIKeyLoginResponse {
    /**
     * The response data. Populated if `success` is true.
     */
    data?: APIKeyLoginResponse | null;
    /**
     * A message for any error that may occur. Populated if `success` is false.
     */
    errorMessage?: null | string;
    /**
     * Whether or not the SDK request succeeded.
     */
    success: boolean;
}
export interface APIKeyLoginResponse {
    authenticated: boolean;
    /**
     * Whether or not the user is required to update their master password
     */
    forcePasswordReset: boolean;
    /**
     * TODO: What does this do?
     */
    resetMasterPassword: boolean;
    twoFactor?: APIKeyLoginResponseTwoFactorProviders | null;
}
export interface APIKeyLoginResponseTwoFactorProviders {
    authenticator?: PurpleAuthenticator | null;
    /**
     * Duo-backed 2fa
     */
    duo?: PurpleDuo | null;
    /**
     * Email 2fa
     */
    email?: PurpleEmail | null;
    /**
     * Duo-backed 2fa operated by an organization the user is a member of
     */
    organizationDuo?: PurpleDuo | null;
    /**
     * Presence indicates the user has stored this device as bypassing 2fa
     */
    remember?: PurpleRemember | null;
    /**
     * WebAuthn-backed 2fa
     */
    webAuthn?: PurpleWebAuthn | null;
    /**
     * Yubikey-backed 2fa
     */
    yubiKey?: PurpleYubiKey | null;
}
export interface PurpleAuthenticator {
}
export interface PurpleDuo {
    host: string;
    signature: string;
}
export interface PurpleEmail {
    /**
     * The email to request a 2fa TOTP for
     */
    email: string;
}
export interface PurpleRemember {
}
export interface PurpleWebAuthn {
}
export interface PurpleYubiKey {
    /**
     * Whether the stored yubikey supports near field communication
     */
    nfc: boolean;
}
export interface ResponseForFingerprintResponse {
    /**
     * The response data. Populated if `success` is true.
     */
    data?: FingerprintResponse | null;
    /**
     * A message for any error that may occur. Populated if `success` is false.
     */
    errorMessage?: null | string;
    /**
     * Whether or not the SDK request succeeded.
     */
    success: boolean;
}
export interface FingerprintResponse {
    fingerprint: string;
}
export interface ResponseForPasswordLoginResponse {
    /**
     * The response data. Populated if `success` is true.
     */
    data?: PasswordLoginResponse | null;
    /**
     * A message for any error that may occur. Populated if `success` is false.
     */
    errorMessage?: null | string;
    /**
     * Whether or not the SDK request succeeded.
     */
    success: boolean;
}
export interface PasswordLoginResponse {
    authenticated: boolean;
    /**
     * The information required to present the user with a captcha challenge. Only present when
     * authentication fails due to requiring validation of a captcha challenge.
     */
    captcha?: CAPTCHAResponse | null;
    /**
     * Whether or not the user is required to update their master password
     */
    forcePasswordReset: boolean;
    /**
     * TODO: What does this do?
     */
    resetMasterPassword: boolean;
    /**
     * The available two factor authentication options. Present only when authentication fails
     * due to requiring a second authentication factor.
     */
    twoFactor?: PasswordLoginResponseTwoFactorProviders | null;
}
export interface CAPTCHAResponse {
    /**
     * hcaptcha site key
     */
    siteKey: string;
}
export interface PasswordLoginResponseTwoFactorProviders {
    authenticator?: FluffyAuthenticator | null;
    /**
     * Duo-backed 2fa
     */
    duo?: FluffyDuo | null;
    /**
     * Email 2fa
     */
    email?: FluffyEmail | null;
    /**
     * Duo-backed 2fa operated by an organization the user is a member of
     */
    organizationDuo?: FluffyDuo | null;
    /**
     * Presence indicates the user has stored this device as bypassing 2fa
     */
    remember?: FluffyRemember | null;
    /**
     * WebAuthn-backed 2fa
     */
    webAuthn?: FluffyWebAuthn | null;
    /**
     * Yubikey-backed 2fa
     */
    yubiKey?: FluffyYubiKey | null;
}
export interface FluffyAuthenticator {
}
export interface FluffyDuo {
    host: string;
    signature: string;
}
export interface FluffyEmail {
    /**
     * The email to request a 2fa TOTP for
     */
    email: string;
}
export interface FluffyRemember {
}
export interface FluffyWebAuthn {
}
export interface FluffyYubiKey {
    /**
     * Whether the stored yubikey supports near field communication
     */
    nfc: boolean;
}
export interface ResponseForProjectResponse {
    /**
     * The response data. Populated if `success` is true.
     */
    data?: ProjectResponse | null;
    /**
     * A message for any error that may occur. Populated if `success` is false.
     */
    errorMessage?: null | string;
    /**
     * Whether or not the SDK request succeeded.
     */
    success: boolean;
}
export interface ProjectResponse {
    creationDate: Date;
    id: string;
    name: string;
    organizationId: string;
    revisionDate: Date;
}
export interface ResponseForProjectsDeleteResponse {
    /**
     * The response data. Populated if `success` is true.
     */
    data?: ProjectsDeleteResponse | null;
    /**
     * A message for any error that may occur. Populated if `success` is false.
     */
    errorMessage?: null | string;
    /**
     * Whether or not the SDK request succeeded.
     */
    success: boolean;
}
export interface ProjectsDeleteResponse {
    data: ProjectDeleteResponse[];
}
export interface ProjectDeleteResponse {
    error?: null | string;
    id: string;
}
export interface ResponseForProjectsResponse {
    /**
     * The response data. Populated if `success` is true.
     */
    data?: ProjectsResponse | null;
    /**
     * A message for any error that may occur. Populated if `success` is false.
     */
    errorMessage?: null | string;
    /**
     * Whether or not the SDK request succeeded.
     */
    success: boolean;
}
export interface ProjectsResponse {
    data: DatumElement[];
}
export interface DatumElement {
    creationDate: Date;
    id: string;
    name: string;
    organizationId: string;
    revisionDate: Date;
}
export interface ResponseForSecretIdentifiersResponse {
    /**
     * The response data. Populated if `success` is true.
     */
    data?: SecretIdentifiersResponse | null;
    /**
     * A message for any error that may occur. Populated if `success` is false.
     */
    errorMessage?: null | string;
    /**
     * Whether or not the SDK request succeeded.
     */
    success: boolean;
}
export interface SecretIdentifiersResponse {
    data: SecretIdentifierResponse[];
}
export interface SecretIdentifierResponse {
    id: string;
    key: string;
    organizationId: string;
}
export interface ResponseForSecretResponse {
    /**
     * The response data. Populated if `success` is true.
     */
    data?: SecretResponse | null;
    /**
     * A message for any error that may occur. Populated if `success` is false.
     */
    errorMessage?: null | string;
    /**
     * Whether or not the SDK request succeeded.
     */
    success: boolean;
}
export interface SecretResponse {
    creationDate: Date;
    id: string;
    key: string;
    note: string;
    organizationId: string;
    projectId?: null | string;
    revisionDate: Date;
    value: string;
}
export interface ResponseForSecretsDeleteResponse {
    /**
     * The response data. Populated if `success` is true.
     */
    data?: SecretsDeleteResponse | null;
    /**
     * A message for any error that may occur. Populated if `success` is false.
     */
    errorMessage?: null | string;
    /**
     * Whether or not the SDK request succeeded.
     */
    success: boolean;
}
export interface SecretsDeleteResponse {
    data: SecretDeleteResponse[];
}
export interface SecretDeleteResponse {
    error?: null | string;
    id: string;
}
export interface ResponseForSecretsResponse {
    /**
     * The response data. Populated if `success` is true.
     */
    data?: SecretsResponse | null;
    /**
     * A message for any error that may occur. Populated if `success` is false.
     */
    errorMessage?: null | string;
    /**
     * Whether or not the SDK request succeeded.
     */
    success: boolean;
}
export interface SecretsResponse {
    data: DatumClass[];
}
export interface DatumClass {
    creationDate: Date;
    id: string;
    key: string;
    note: string;
    organizationId: string;
    projectId?: null | string;
    revisionDate: Date;
    value: string;
}
export interface ResponseForSyncResponse {
    /**
     * The response data. Populated if `success` is true.
     */
    data?: SyncResponse | null;
    /**
     * A message for any error that may occur. Populated if `success` is false.
     */
    errorMessage?: null | string;
    /**
     * Whether or not the SDK request succeeded.
     */
    success: boolean;
}
export interface SyncResponse {
    /**
     * List of ciphers accesible by the user
     */
    ciphers: CipherDetailsResponse[];
    /**
     * Data about the user, including their encryption keys and the organizations they are a
     * part of
     */
    profile: ProfileResponse;
}
export interface CipherDetailsResponse {
}
/**
 * Data about the user, including their encryption keys and the organizations they are a
 * part of
 */
export interface ProfileResponse {
    email: string;
    id: string;
    name: string;
    organizations: ProfileOrganizationResponse[];
}
export interface ProfileOrganizationResponse {
    id: string;
}
export interface ResponseForUserAPIKeyResponse {
    /**
     * The response data. Populated if `success` is true.
     */
    data?: UserAPIKeyResponse | null;
    /**
     * A message for any error that may occur. Populated if `success` is false.
     */
    errorMessage?: null | string;
    /**
     * Whether or not the SDK request succeeded.
     */
    success: boolean;
}
export interface UserAPIKeyResponse {
    /**
     * The user's API key, which represents the client_secret portion of an oauth request.
     */
    apiKey: string;
}
export declare class Convert {
    static toClientSettings(json: string): ClientSettings;
    static clientSettingsToJson(value: ClientSettings): string;
    static toCommand(json: string): Command;
    static commandToJson(value: Command): string;
    static toDocRef(json: string): DocRef;
    static docRefToJson(value: DocRef): string;
    static toResponseForAPIKeyLoginResponse(json: string): ResponseForAPIKeyLoginResponse;
    static responseForAPIKeyLoginResponseToJson(value: ResponseForAPIKeyLoginResponse): string;
    static toResponseForFingerprintResponse(json: string): ResponseForFingerprintResponse;
    static responseForFingerprintResponseToJson(value: ResponseForFingerprintResponse): string;
    static toResponseForPasswordLoginResponse(json: string): ResponseForPasswordLoginResponse;
    static responseForPasswordLoginResponseToJson(value: ResponseForPasswordLoginResponse): string;
    static toResponseForProjectResponse(json: string): ResponseForProjectResponse;
    static responseForProjectResponseToJson(value: ResponseForProjectResponse): string;
    static toResponseForProjectsDeleteResponse(json: string): ResponseForProjectsDeleteResponse;
    static responseForProjectsDeleteResponseToJson(value: ResponseForProjectsDeleteResponse): string;
    static toResponseForProjectsResponse(json: string): ResponseForProjectsResponse;
    static responseForProjectsResponseToJson(value: ResponseForProjectsResponse): string;
    static toResponseForSecretIdentifiersResponse(json: string): ResponseForSecretIdentifiersResponse;
    static responseForSecretIdentifiersResponseToJson(value: ResponseForSecretIdentifiersResponse): string;
    static toResponseForSecretResponse(json: string): ResponseForSecretResponse;
    static responseForSecretResponseToJson(value: ResponseForSecretResponse): string;
    static toResponseForSecretsDeleteResponse(json: string): ResponseForSecretsDeleteResponse;
    static responseForSecretsDeleteResponseToJson(value: ResponseForSecretsDeleteResponse): string;
    static toResponseForSecretsResponse(json: string): ResponseForSecretsResponse;
    static responseForSecretsResponseToJson(value: ResponseForSecretsResponse): string;
    static toResponseForSyncResponse(json: string): ResponseForSyncResponse;
    static responseForSyncResponseToJson(value: ResponseForSyncResponse): string;
    static toResponseForUserAPIKeyResponse(json: string): ResponseForUserAPIKeyResponse;
    static responseForUserAPIKeyResponseToJson(value: ResponseForUserAPIKeyResponse): string;
}
